★
생일문제에서 볼 수 있듯이 일반적인 상식과는 달리, 
충돌은 생각보다 쉽게 일어나므로 충돌을 최소화하는 일이 중요

★생일문제
: 같은해에 태어난 23명을 뽑는다. 
23명 중 생일이 같으면 성공, 다르면 실패, 10만번의 실험
-> 생일이 같을 경우가 50%가 넘는다.
=> 충돌은 생각보다 쉽게 일어남.

★비둘기집 원리
:n개 아이템을 m개의 컨테이너에 넣을 때, n > m이라면 적어도 하나의
컨테이너에는 반드시 2개이상의 아이템이 들어가 있다.
-> 좋은해시는 1번의 충돌만 일어나겠지만, 그렇지 않은 해쉬는 9번의 충돌도 일어날 수 있다.

★로드 팩터
:해시 테이블에 저장된 데이터 개수n을 버킷의 개수 k로 나눈것
load_factor = n / k

★해시 함수
:해시 함수를 통해 키가 해시 값으로 변경되는 과정 
ex) 윤아=2 현건=1 은아=5 .. (1~15로 칸을 나누었을때)
해싱에는 여러 기법들이 있다. 우리는 나눗셈 방식(Modulo-Division Method)를 살펴보자
(가장 단순하면서 널리 쓰이는 정수형 해싱 기법인 모듈이다.)
h(x) = x mod m (x를 m으로 나누었을 때의 나머지)

★충돌 시 대처
1. 개별 체이닝
:충돌시 연결리스트로 잇는다.
(최적화하기위해 자바8에서는 데이터 개수가 많아지면 레드-블랙트리에 저장하는 형태로 변형한다고 함.)
2. 오픈 어드레싱
:충돌 시 탐사를 통해 빈 공간을 찾아나서는 방식
(이 때문에 개별 체이닝 방식과 달리, 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장이 없다.)
(빈공간을 찾을 때, 충돌된 곳 다음의 위치를 보기때문에 데이터가 고르게 분포되지 않는 경향이 있다.)
 - 클러스터링: 해시 테이블 여기저기에 연속된 데이터 그룹이 생기는 현상
 - 클러스터들이 점점 커지게 되면 인근 클러스터들과 서로 합쳐지는 일이 발생한다.
 -> 전체적으로 해싱 효율을 떨어뜨림.
일정 이상 채워지면, 즉 기준이 되는 로드 팩터 비율을 넘어서게 되면, 그로스 팩터(Growth Factor)의 비율에 따라
더 큰 크기의 또 다른 버킷을 생선한 후 여기에 새롭게 복사하는 리해싱(Rehashing) 작업이 일어난다. 
더블링으로 새롭게 복사해서 옮겨가는 과정과 유사하다.

파이썬은 딕셔너리가 해시 테이블로 구현된 자료형이다. 오픈 어드레싱 방식으로 구현되어있다.
why-> CPython구현을 보면 다음과 같은 주석이 있다고한다.
    └ 체이닝 시 malloc으로 메모리를 할당하는 오버헤드가 높아 오픈 어드레싱을 택했다.
=> 오픈 어드레싱의 한 방식인 선형 탐사 방식이 일반적으로 체이닝에 비해 성능이 더 좋다.(구글에 이미지 참고)
단, 슬롯의 80%이상 차지하게 되면 급격한 성능 저하가 일어나며, 체이닝과 달리 전체 슬롯의 전체 개수 이상, 즉 로드 팩터 1 이상은 저장할 수 없다.
그래서 파이썬의 로드팩터는 0.66, 루비는0.5로 자바보다 작게 디폴트값을 줌.

c++, JAVA, 고(Go) = 개별체이닝
Python, Ruby = 오픈 어드레싱()

★관련 이슈
1. 구글은 해시 함수를 딥러닝으로 학습한 모델을 적용해 충돌을 최소하는 논문을 발표.
[The Case for Learned Index Structures]

